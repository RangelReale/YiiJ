package com.yiij.web;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.yiij.Root;
import com.yiij.base.Application;
import com.yiij.base.HttpException;
import com.yiij.base.interfaces.IContext;
import com.yiij.utils.StringHelper;
import com.yiij.web.interfaces.IViewRenderer;
import com.yiij.web.interfaces.IWebModule;
import com.yiij.web.actions.Action;
import com.yiij.web.actions.InlineAction;

public class Controller extends BaseController
{
	private String _defaultAction = "index";
	private String _layout;
	private String _id;
	private IWebModule _module;
	private Action _action;

	private final Logger logger = LoggerFactory.getLogger(Controller.class);	
	
	public Controller(IContext context, String id, IWebModule module)
	{
		super(context);
		_id = id;
		_module = module;
	}
	
	/**
	 * The name of the default action. Defaults to 'index'.
	 * @result string 
	 */
	public String getDefaultAction()
	{
		return _defaultAction;
	}

	/**
	 * @see #getDefaultAction()
	 * @param String
	 */
	public void setDefaultAction(String value)
	{
		_defaultAction = value;
	}
	
	/**
	 * The name of the layout to be applied to this controller's views.
	 * Defaults to null, meaning the {@link WebApplication#getLayout() application layout}
	 * is used. If it is blank, no layout will be applied.
	 * The {@link WebModule#getLayout() module layout} will be used
	 * if the controller belongs to a module and this layout property is null.
	 * @return String 
	 */
	public String getLayout()
	{
		return _layout;
	}
	
	/**
	 * @see #getLayout()
	 * @param String
	 */
	public void setLayout(String value)
	{
		_layout = value;
	}

	public Object filters()
	{
		return null;
	}
	
	public Object actions()
	{
		return null;
	}
	
	public Object acessRules()
	{
		return null;
	}
	
	public void run(String actionID) throws Exception
	{
		Action action = createAction(actionID);
		if (action != null)
		{
			//if(($parent=$this->getModule())===null)
				//$parent=Yii::app();
			//if($parent->beforeControllerAction($this,$action))
			//{
				runActionWithFilters(action,filters());
				//$parent->afterControllerAction($this,$action);
			//}
			
		}
		else
			missingAction(actionID);
	}
	
	public void runActionWithFilters(Action action, Object filters) throws Exception
	{
		if (filters == null)
			runAction(action);
		else
		{
			// TODO
		}
		
	}
	
	public void runAction(Action action) throws Exception
	{
		action.run();
	}

	/*
	public Map<String, String> getActionParams()
	{
		
	}
	*/
	
	/**
	 * This method is invoked when the request parameters do not satisfy the requirement of the specified action.
	 * The default implementation will throw a 400 HTTP exception.
	 * @param action the action being executed
	 */
	public void invalidActionParams(Action action) throws HttpException
	{
		throw new HttpException(400,"Your request is invalid.");
	}
	
	/**
	 * Postprocesses the output generated by {@link #render()}.
	 * This method is invoked at the end of {@link #render()} and {@link #renderText()}.
	 * If there are registered client scripts, this method will insert them into the output
	 * at appropriate places. If there are dynamic contents, they will also be inserted.
	 * This method may also save the persistent page states in hidden fields of
	 * stateful forms in the page.
	 * @param output output the output generated by the current action
	 * @return the output that has been processed.
	 */
	public String processOutput(String output)
	{
		// TODO
		return output;
	}
	
	/**
	 * Creates the action instance based on the action name.
	 * The action can be either an inline action or an object.
	 * The latter is created by looking up the action map specified in {@link #actions()}.
	 * @param actionID ID of the action. If empty, the {@link #getDefaultAction() default action} will be used.
	 * @return the action instance, null if the action does not exist.
	 * @see #actions()
	 */
	public Action createAction(String actionID) throws Exception
	{
		if (actionID.equals(""))
			actionID = _defaultAction;
		
		String actionMethodName = "action"+StringHelper.upperCaseFirst(actionID);
		try
		{
			getClass().getMethod(actionMethodName, new Class[] {});
			
			return new InlineAction(this, actionID);
		} catch (SecurityException e)
		{
		} catch (NoSuchMethodException e)
		{
		}
		// TODO
		throw new Exception("Action class {class} must implement the 'run' method.");
	}

	/**
	 * Handles the request whose action is not recognized.
	 * This method is invoked when the controller cannot find the requested action.
	 * The default implementation simply throws an exception.
	 * @param actionID the missing action name
	 * @throws HttpException whenever this method is invoked
	 */
	public void missingAction(String actionID) throws HttpException
	{
		throw new HttpException(404, "The system is unable to find the requested action '{action}'");
	}	
	
	/**
	 * @return the action currently being executed, null if no active action.
	 */
	public Action getAction()
	{
		return _action;
	}
	
	/**
	 * @param value the action currently being executed.
	 */
	public void setAction(Action value)
	{
		_action = value;
	}
	
	
	/**
	 * @return ID of the controller
	 */
	public String getId()
	{
		return _id;
	}

	/**
	 * @return the controller ID that is prefixed with the module ID (if any).
	 */
	public String getUniqueId()
	{
		return (_module != null) ?_module.getId()+"/"+_id : _id;
	}
	
	/**
	 * @return the route (module ID, controller ID and action ID) of the current request.
	 * @since 1.1.0
	 */
	public String getRoute()
	{
		Action action;
		if((action = getAction())!=null)
			return getUniqueId()+"/"+action.getId();
		else
			return getUniqueId();
	}
	
	/**
	 * @return the module that this controller belongs to. It returns null
	 * if the controller does not belong to any module
	 */
	public IWebModule getModule()
	{
		return _module;
	}

	/*
	public String getViewPackageName()
	{
		IWebModule module = getModule();
		if (module == null)
			module = webApp();
		return module.getViewPackageName()+"."+getId();
	}
	*/
	
	/**
	 * Returns the directory containing view files for this controller.
	 * The default implementation returns 'protected/views/ControllerID'.
	 * Child classes may override this method to use customized view path.
	 * If the controller belongs to a module, the default view path
	 * is the {@link WebModule#getViewPath() module view path} appended with the controller ID.
	 * @return the directory containing the view files for this controller. Defaults to 'protected/views/ControllerID'.
	 */
	public String getViewPath()
	{
		IWebModule module;
		if((module = (IWebModule)getModule())==null)
			module = webApp();
		IViewRenderer renderer = webApp().getViewRenderer();
		if (renderer.getFileExtension()!=null)
			return module.getViewPath()+"/"+getId();
		else
			return module.getViewPath()+"."+StringHelper.upperCaseFirst(getId());
	}
	
	/**
	 * Looks for the view file according to the given view name.
	 *
	 * When a theme is currently active, this method will call {@link Theme#getViewFile()} to determine
	 * which view file should be returned.
	 *
	 * Otherwise, this method will return the corresponding view file based on the following criteria:
	 * <ul>
	 * <li>absolute view within a module: the view name starts with a single slash '/'.
	 * In this case, the view will be searched for under the currently active module's view path.
	 * If there is no active module, the view will be searched for under the application's view path.</li>
	 * <li>absolute view within the application: the view name starts with double slashes '//'.
	 * In this case, the view will be searched for under the application's view path.
	 * This syntax has been available since version 1.1.3.</li>
	 * <li>aliased view: the view name contains dots and refers to a path alias.
	 * The view file is determined by calling {@link Root#getPathOfAlias()}. Note that aliased views
	 * cannot be themed because they can refer to a view file located at arbitrary places.</li>
	 * <li>relative view: otherwise. Relative views will be searched for under the currently active
	 * controller's view path.</li>
	 * </ul>
	 *
	 * After the view file is identified, this method may further call {@link Application#findLocalizedFile()}
	 * to find its localized version if internationalization is needed.
	 *
	 * @param viewName view name
	 * @return the view file path, false if the view file does not exist
	 * @see #resolveViewFile()
	 * @see Application#findLocalizedFile()
	 */
	public String getViewFile(String viewName)
	{
		/*
		if((($theme=Yii::app()->getTheme())!==null || ($theme=Yii::app()->themeManager->getTheme($this->getModule()!==null?$this->getModule()->theme:null))!==null) && ($viewFile=$theme->getViewFile($this,$viewName))!==false)
			return $viewFile;
		*/
		String moduleViewPath = webApp().getViewPath();
		String basePath = moduleViewPath;
		IWebModule module;
		if ((module = getModule()) != null)
			moduleViewPath = module.getViewPath();
		return resolveViewFile(viewName,getViewPath(),basePath,moduleViewPath);
	}

	/**
	 * Looks for the layout view script based on the layout name.
	 *
	 * The layout name can be specified in one of the following ways:
	 *
	 * <ul>
	 * <li>layout is false: returns false, meaning no layout.</li>
	 * <li>layout is null: the currently active module's layout will be used. If there is no active module,
	 * the application's layout will be used.</li>
	 * <li>a regular view name.</li>
	 * </ul>
	 *
	 * The resolution of the view file based on the layout view is similar to that in {@link getViewFile}.
	 * In particular, the following rules are followed:
	 *
	 * Otherwise, this method will return the corresponding view file based on the following criteria:
	 * <ul>
	 * <li>When a theme is currently active, this method will call {@link CTheme::getLayoutFile} to determine
	 * which view file should be returned.</li>
	 * <li>absolute view within a module: the view name starts with a single slash '/'.
	 * In this case, the view will be searched for under the currently active module's view path.
	 * If there is no active module, the view will be searched for under the application's view path.</li>
	 * <li>absolute view within the application: the view name starts with double slashes '//'.
	 * In this case, the view will be searched for under the application's view path.
	 * This syntax has been available since version 1.1.3.</li>
	 * <li>aliased view: the view name contains dots and refers to a path alias.
	 * The view file is determined by calling {@link YiiBase::getPathOfAlias()}. Note that aliased views
	 * cannot be themed because they can refer to a view file located at arbitrary places.</li>
	 * <li>relative view: otherwise. Relative views will be searched for under the currently active
	 * module's layout path. In case when there is no active module, the view will be searched for
	 * under the application's layout path.</li>
	 * </ul>
	 *
	 * After the view file is identified, this method may further call {@link CApplication::findLocalizedFile}
	 * to find its localized version if internationalization is needed.
	 *
	 * @param mixed $layoutName layout name
	 * @return string the view file for the layout. False if the view file cannot be found
	 */
	public String getLayoutFile(String layoutName)
	{
		if(layoutName != null && layoutName.equals(""))
			return null;
		//if((($theme=Yii::app()->getTheme())!==null || ($theme=Yii::app()->themeManager->getTheme($this->getModule()!==null?$this->getModule()->theme:null))!==null) && ($layoutFile=$theme->getLayoutFile($this,$layoutName))!==false)
			//return $layoutFile;

		IWebModule module;
		if(layoutName == null)
		{
			module = getModule();
			while(module!=null)
			{
				if(module.getLayout()!=null && module.getLayout().equals(""))
					return null;
				if(module.getLayout()!=null)
					break;
				module=(IWebModule)module.getParentModule();
			}
			if(module==null)
				module=webApp();
			layoutName=module.getLayout();
		}
		else if((module=this.getModule())==null)
			module=webApp();
		
		return resolveViewFile(layoutName,module.getLayoutPath(),webApp().getViewPath(),module.getViewPath());
	}
	
	/**
	 * Finds a view file based on its name.
	 * The view name can be in one of the following formats:
	 * <ul>
	 * <li>absolute view within a module: the view name starts with a single slash '/'.
	 * In this case, the view will be searched for under the currently active module's view path.
	 * If there is no active module, the view will be searched for under the application's view path.</li>
	 * <li>absolute view within the application: the view name starts with double slashes '//'.
	 * In this case, the view will be searched for under the application's view path.
	 * This syntax has been available since version 1.1.3.</li>
	 * <li>aliased view: the view name contains dots and refers to a path alias.
	 * The view file is determined by calling {@link YiiBase::getPathOfAlias()}. Note that aliased views
	 * cannot be themed because they can refer to a view file located at arbitrary places.</li>
	 * <li>relative view: otherwise. Relative views will be searched for under the currently active
	 * controller's view path.</li>
	 * </ul>
	 * For absolute view and relative view, the corresponding view file is a PHP file
	 * whose name is the same as the view name. The file is located under a specified directory.
	 * This method will call {@link Application#findLocalizedFile()} to search for a localized file, if any.
	 * @param viewName the view name
	 * @param viewPath the directory that is used to search for a relative view name
	 * @param basePath the directory that is used to search for an absolute view name under the application
	 * @param moduleViewPath the directory that is used to search for an absolute view name under the current module.
	 * If this is not set, the application base view path will be used.
	 * @return the view file path. null if the view file does not exist. blank ("") if not file based.
	 */
	public String resolveViewFile(String viewName, String viewPath, String basePath, String moduleViewPath)
	{
		logger.trace("{}: resolveViewFile {}, {}, {}, {}", new Object[] { getClass().getCanonicalName(), viewName, viewPath, basePath, moduleViewPath} );
		
		if (viewName == null || viewName.equals(""))
			return null;

		if(moduleViewPath == null)
			moduleViewPath = basePath;

		IViewRenderer renderer = webApp().getViewRenderer();
		boolean isClassBased = renderer.getFileExtension() == null;
		String extension = renderer.getFileExtension();
		
		String viewFile;
		if(viewName.startsWith("/"))
		{
			if (isClassBased)
				throw new com.yiij.base.Exception("Slash layout operation not supported for class-based layout");
			if (viewName.startsWith("//"))
				viewFile=basePath+viewName;
			else
				viewFile=moduleViewPath+viewName;
		}
		else if(viewName.indexOf(".")!=-1)
		{
			if (!isClassBased)
				viewFile = webApp().getPathOfAlias(viewName);
			else
				viewFile = viewName; // if contains dot, is a full class name (ex.: "com.test.layouts.MainLayout")
		}
		else
		{
			if (!isClassBased)
				viewFile=viewPath+"/"+viewName;
			else
			{
				IWebModule baseModule = getModule();
				if (baseModule == null)
					baseModule = webApp();
				viewFile=baseModule.getPackageName()+viewPath+""+StringHelper.upperCaseFirst(viewName)+"View";
			}
		}

		if (isClassBased)
			return viewFile;
		else if (Object.class.getResource(viewFile+extension)!=null)
			return viewFile+extension; //Yii::app()->findLocalizedFile($viewFile.$extension);
		//else if($extension!=='.php' && is_file($viewFile.'.php'))
			//return Yii::app()->findLocalizedFile($viewFile.'.php');
		else
			return null;
	}
	
	/**
	 * @see #render(String, Object, boolean)
	 * @throws IOException
	 */
	public String render(String view,Object data) throws IOException
	{
		return render(view, data, false);
	}
	
	/**
	 * Renders a view with a layout.
	 *
	 * This method first calls {@link renderPartial} to render the view (called content view).
	 * It then renders the layout view which may embed the content view at appropriate place.
	 * In the layout view, the content view rendering result can be accessed via variable
	 * <code>$content</code>. At the end, it calls {@link processOutput} to insert scripts
	 * and dynamic contents if they are available.
	 *
	 * By default, the layout view script is "protected/views/layouts/main.php".
	 * This may be customized by changing {@link layout}.
	 *
	 * @param string $view name of the view to be rendered. See {@link getViewFile} for details
	 * about how the view script is resolved.
	 * @param array $data data to be extracted into PHP variables and made available to the view script
	 * @param boolean $return whether the rendering result should be returned instead of being displayed to end users.
	 * @return string the rendering result. Null if the rendering result is not required.
	 * @throws IOException 
	 * @see renderPartial
	 * @see getLayoutFile
	 */
	public String render(String view,Object data, boolean doReturn) throws IOException
	{
		if(beforeRender(view))
		{
			String output = renderPartial(view,data,true);
			String layoutFile;
			if((layoutFile=getLayoutFile(getLayout()))!=null) 
			{
				HashMap<String, String> lparams = new HashMap<String, String>();
				lparams.put("content", output);
				output=renderFile(layoutFile,lparams, true);
			}

			afterRender(view,output);

			output=processOutput(output);

			if(doReturn)
				return output;
			else
				webApp().getResponse().getWriter().print(output);
		}
		return null;
	}
	
	
	/**
	 * This method is invoked at the beginning of {@link #render()}.
	 * You may override this method to do some preprocessing when rendering a view.
	 * @param view the view to be rendered
	 * @return whether the view should be rendered.
	 */
	protected boolean beforeRender(String view)
	{
		return true;
	}

	/**
	 * This method is invoked after the specified is rendered by calling {@link #render()}.
	 * Note that this method is invoked BEFORE {@link #processOutput()}.
	 * You may override this method to do some postprocessing for the view rendering.
	 * @param view the view that has been rendered
	 * @param output the rendering result of the view. Note that this parameter is passed
	 * as a reference. That means you can modify it within this method.
	 */
	protected void afterRender(String view, String output)
	{
	}
	
	/**
	 * @see #renderText(String, boolean)
	 */
	public void renderText(String text) throws IOException
	{
		renderText(text, false);
	}
	
	/**
	 * Renders a static text string.
	 * The string will be inserted in the current controller layout and returned back.
	 * @param text the static text string
	 * @param doReturn whether the rendering result should be returned instead of being displayed to end users.
	 * @return the rendering result. Null if the rendering result is not required.
	 * @throws IOException 
	 * @see #getLayoutFile()
	 */
	public String renderText(String text, boolean doReturn) throws IOException
	{
		String layoutFile;
		if((layoutFile=getLayoutFile(getLayout()))!=null) 
		{
			HashMap<String, String> lparams = new HashMap<String, String>();
			lparams.put("content", text);
			text=renderFile(layoutFile,lparams, true);
		}
		
		text = processOutput(text);

		if(doReturn)
			return text;
		else
			webApp().getResponse().getWriter().print(text);
		return null;
	}	

	/**
	 * @see #renderPartial(String, Object, boolean, boolean) 
	 */
	public String renderPartial(String view, Object data) throws IOException
	{
		return renderPartial(view, data, false, false);
	}
	
	/**
	 * @see #renderPartial(String, Object, boolean, boolean) 
	 */
	public String renderPartial(String view, Object data, boolean doReturn) throws IOException
	{
		return renderPartial(view, data, doReturn, false);
	}
	
	/**
	 * Renders a view.
	 *
	 * The named view refers to a PHP script (resolved via {@link getViewFile})
	 * that is included by this method. If $data is an associative array,
	 * it will be extracted as PHP variables and made available to the script.
	 *
	 * This method differs from {@link render()} in that it does not
	 * apply a layout to the rendered result. It is thus mostly used
	 * in rendering a partial view, or an AJAX response.
	 *
	 * @param string $view name of the view to be rendered. See {@link getViewFile} for details
	 * about how the view script is resolved.
	 * @param array $data data to be extracted into PHP variables and made available to the view script
	 * @param boolean $return whether the rendering result should be returned instead of being displayed to end users
	 * @param boolean $processOutput whether the rendering result should be postprocessed using {@link processOutput}.
	 * @return string the rendering result. Null if the rendering result is not required.
	 * @throws IOException 
	 * @throws CException if the view does not exist
	 * @see getViewFile
	 * @see processOutput
	 * @see render
	 */
	public String renderPartial(String view, Object data, boolean doReturn, boolean processOutput) throws IOException
	{
		String viewFile;
		if((viewFile=getViewFile(view))!=null)
		{
			String output = renderFile(viewFile,data,doReturn);
			if(processOutput)
				output = processOutput(output);
			if(doReturn)
				return output;
			else
				webApp().getResponse().getWriter().print(output);
			return null;
		}
		else
			throw new com.yiij.base.Exception(getClass().getCanonicalName()+" cannot find the requested view '"+view+"'.");
	}
	
	/**
	 * Creates a relative URL for the specified action defined in this controller.
	 * @param route the URL route. This should be in the format of 'ControllerID/ActionID'.
	 * If the ControllerID is not present, the current controller ID will be prefixed to the route.
	 * If the route is empty, it is assumed to be the current action.
	 * If the controller belongs to a module, the {@link CWebModule::getId module ID}
	 * will be prefixed to the route. (If you do not want the module ID prefix, the route should start with a slash '/'.)
	 * @param params additional GET parameters (name=>value). Both the name and value will be URL-encoded.
	 * If the name is '#', the corresponding value will be treated as an anchor
	 * and will be appended at the end of the URL.
	 * @param ampersand the token separating name-value pairs in the URL.
	 * @return the constructed URL
	 */
	public String createUrl(String route, Map<String, String> params, String ampersand)
	{
		IWebModule module;
		if(route.equals(""))
			route=getId()+"/"+getAction().getId();
		else if(route.indexOf("/")==-1)
			route=getId()+"/"+route;
		if(!route.startsWith("/") && (module=getModule())!=null)
			route=module.getId()+"/"+route;
		return webApp().createUrl(StringUtils.strip(route, "/"), params, ampersand);
	}	
	
	/**
	 * Creates an absolute URL for the specified action defined in this controller.
	 * @param route the URL route. This should be in the format of 'ControllerID/ActionID'.
	 * If the ControllerPath is not present, the current controller ID will be prefixed to the route.
	 * If the route is empty, it is assumed to be the current action.
	 * @param params additional GET parameters (name=>value). Both the name and value will be URL-encoded.
	 * @param schema schema to use (e.g. http, https). If empty, the schema used for the current request will be used.
	 * @param ampersand the token separating name-value pairs in the URL.
	 * @return the constructed URL
	 */
	public String createAbsoluteUrl(String route, Map<String, String> params, String schema, String ampersand)
	{
		String url=createUrl(route,params,ampersand);
		if(url.startsWith("http"))
			return url;
		else
			return webApp().getRequest().getHostInfo(schema)+url;
	}
	
	/**
	 * This method is invoked right before an action is to be executed (after all possible filters.)
	 * You may override this method to do last-minute preparation for the action.
	 * @param action the action to be executed.
	 * @return whether the action should be executed.
	 */
	protected boolean beforeAction(Action action)
	{
		return true;
	}

	/**
	 * This method is invoked right after an action is executed.
	 * You may override this method to do some postprocessing for the action.
	 * @param action the action just executed.
	 */
	protected void afterAction(Action action)
	{
	}
	
}
