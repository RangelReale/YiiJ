package com.yiij.web;

import java.io.IOException;
import java.util.Stack;

import com.yiij.base.interfaces.IContext;
import com.yiij.web.interfaces.IViewRenderer;
import com.yiij.web.widgets.Widget;

public abstract class BaseController extends WebComponent
{
	private Stack<Widget> _widgetStack = new Stack<Widget>();
	
	public BaseController(IContext context)
	{
		super(context);
	}

	/**
	 * Returns the view script file according to the specified view name.
	 * This method must be implemented by child classes.
	 * @param viewName view name
	 * @return the file path for the named view. null if the view cannot be found. blank ("") if not file based.
	 */
	abstract public String getViewFile(String viewName);
	
	//abstract public String getViewPackageName();
	
	/**
	 * @see #renderWithRenderer(String, Object, boolean)
	 */
	public String renderWithRenderer(IViewRenderer renderer, String viewFile, Object data) throws IOException
	{
		return renderWithRenderer(renderer, viewFile, data, false);
	}
	
	/**
	 * Renders a view using a IViewRenderer.
	 *
	 * @param viewFile view file path
	 * @param data data to be extracted and made available to the view
	 * @param return whether the rendering result should be returned instead of being echoed
	 * @return the rendering result. Null if the rendering result is not required.
	 * @throws Exception if the view file does not exist
	 * @throws IOException
	 */
	public String renderWithRenderer(IViewRenderer renderer, String viewFile, Object data, boolean doReturn) throws IOException
	{
		int widgetCount = _widgetStack.size();
		String content = renderer.renderFile(this, viewFile, data, doReturn);
		if(_widgetStack.size()==widgetCount)
			return content;
		else
		{
			BaseController widget=_widgetStack.peek();
			throw new com.yiij.base.Exception(getClass().getCanonicalName()+" contains improperly nested widget tags in its view '"+viewFile+"'. A "+widget.getClass().getCanonicalName()+" widget does not have an endWidget() call.");
		}
	}
	
	/**
	 * Renders a view file.
	 *
	 * @param view view name
	 * @param viewFile view file path
	 * @param data data to be extracted and made available to the view
	 * @param return whether the rendering result should be returned instead of being echoed
	 * @return the rendering result. Null if the rendering result is not required.
	 * @throws Exception if the view file does not exist
	 */
	public String renderFile(String viewFile, Object data, boolean doReturn) throws IOException
	{
		return renderWithRenderer(webApp().getViewRenderer(), viewFile, data, doReturn);
	}
	
	
	/**
	 * Creates a widget and initializes it.
	 * This method first creates the specified widget instance.
	 * It then configures the widget's properties with the given initial values.
	 * At the end it calls {@link CWidget::init} to initialize the widget.
	 * Starting from version 1.1, if a {@link CWidgetFactory widget factory} is enabled,
	 * this method will use the factory to create the widget, instead.
	 * @param properties initial property values
	 * @return the fully initialized widget instance.
	 * @throws InstantiationException 
	 */
	public Widget createWidget(Object properties) throws InstantiationException
	{
		Widget widget = webApp().getWidgetFactory().createWidget(this, properties);
		return widget;
	}
	
	public String widget(Object properties) throws InstantiationException, IOException
	{
		return widget(properties, false);
	}
	
	/**
	 * Creates a widget and executes it.
	 * @param properties list of initial property values for the widget (Property Name => Property Value)
	 * @param captureOutput whether to capture the output of the widget. If true, the method will capture
	 * and return the output generated by the widget. If false, the output will be directly sent for display
	 * and the widget object will be returned. This parameter is available since version 1.1.2.
	 * @return the widget output when $captureOutput is true.
	 * @throws InstantiationException 
	 * @throws IOException 
	 */
	public String widget(Object properties, boolean captureOutput) throws InstantiationException, IOException
	{
		Widget widget;
		if(captureOutput)
		{
			webApp().getResponse().ob_start();
			widget=createWidget(properties);
			widget.run();
			return webApp().getResponse().ob_get_clean();
		}
		else
		{
			widget=createWidget(properties);
			widget.run();
			return null;
		}
	}

	/**
	 * Creates a widget and executes it.
	 * This method is similar to {@link widget()} except that it is expecting
	 * a {@link endWidget()} call to end the execution.
	 * @param string $className the widget class name or class in dot syntax (e.g. application.widgets.MyWidget)
	 * @param array $properties list of initial property values for the widget (Property Name => Property Value)
	 * @return CWidget the widget created to run
	 * @throws InstantiationException 
	 * @see #endWidget()
	 */
	public Widget beginWidget(Object properties) throws InstantiationException
	{
		Widget widget=createWidget(properties);
		_widgetStack.push(widget);
		return widget;
	}

	public Widget endWidget() throws IOException
	{
		return endWidget("");
	}
	
	/**
	 * Ends the execution of the named widget.
	 * This method is used together with {@link beginWidget()}.
	 * @param id optional tag identifying the method call for debugging purpose.
	 * @return the widget just ended running
	 * @throws IOException 
	 * @throws com.yiij.base.Exception if an extra endWidget call is made
	 * @see #beginWidget()
	 */
	public Widget endWidget(String id) throws IOException
	{
		Widget widget;
		if((widget=_widgetStack.pop())!=null)
		{
			widget.run();
			return widget;
		}
		else
			throw new com.yiij.base.Exception(getClass().getCanonicalName()+" has an extra endWidget("+id+") call in its view."); 
	}
	
}
