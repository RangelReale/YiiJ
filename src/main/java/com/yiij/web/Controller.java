package com.yiij.web;

import java.io.IOException;

import com.yiij.base.HttpException;
import com.yiij.base.Module;
import com.yiij.base.interfaces.IContext;
import com.yiij.utils.StringHelper;
import com.yiij.web.interfaces.IViewRenderer;
import com.yiij.web.interfaces.IWebModule;
import com.yiij.web.actions.Action;
import com.yiij.web.actions.InlineAction;

public class Controller extends BaseController
{
	private String _defaultAction = "index";
	private String _layout;
	private String _id;
	private IWebModule _module;
	private Action _action;
	
	public Controller(IContext context, String id, IWebModule module)
	{
		super(context);
		_id = id;
		_module = module;
	}
	
	/**
	 * The name of the default action. Defaults to 'index'.
	 * @result string 
	 */
	public String getDefaultAction()
	{
		return _defaultAction;
	}

	/**
	 * @see #getDefaultAction()
	 * @param String
	 */
	public void setDefaultAction(String value)
	{
		_defaultAction = value;
	}
	
	/**
	 * The name of the layout to be applied to this controller's views.
	 * Defaults to null, meaning the {@link WebApplication#getLayout() application layout}
	 * is used. If it is blank, no layout will be applied.
	 * The {@link WebModule#getLayout() module layout} will be used
	 * if the controller belongs to a module and this layout property is null.
	 * @return String 
	 */
	public String getLayout()
	{
		return _layout;
	}
	
	/**
	 * @see #getLayout()
	 * @param String
	 */
	public void setLayout(String value)
	{
		_layout = value;
	}

	public Object filters()
	{
		return null;
	}
	
	public Object actions()
	{
		return null;
	}
	
	public Object acessRules()
	{
		return null;
	}
	
	public void run(String actionID) throws Exception
	{
		Action action = createAction(actionID);
		if (action != null)
		{
			//if(($parent=$this->getModule())===null)
				//$parent=Yii::app();
			//if($parent->beforeControllerAction($this,$action))
			//{
				runActionWithFilters(action,filters());
				//$parent->afterControllerAction($this,$action);
			//}
			
		}
		else
			missingAction(actionID);
	}
	
	public void runActionWithFilters(Action action, Object filters) throws Exception
	{
		if (filters == null)
			runAction(action);
		else
		{
			// TODO
		}
		
	}
	
	public void runAction(Action action) throws Exception
	{
		action.run();
	}

	/*
	public Map<String, String> getActionParams()
	{
		
	}
	*/
	
	/**
	 * This method is invoked when the request parameters do not satisfy the requirement of the specified action.
	 * The default implementation will throw a 400 HTTP exception.
	 * @param action the action being executed
	 */
	public void invalidActionParams(Action action) throws HttpException
	{
		throw new HttpException(400,"Your request is invalid.");
	}
	
	/**
	 * Postprocesses the output generated by {@link #render()}.
	 * This method is invoked at the end of {@link #render()} and {@link #renderText()}.
	 * If there are registered client scripts, this method will insert them into the output
	 * at appropriate places. If there are dynamic contents, they will also be inserted.
	 * This method may also save the persistent page states in hidden fields of
	 * stateful forms in the page.
	 * @param output output the output generated by the current action
	 * @return the output that has been processed.
	 */
	public String processOutput(String output)
	{
		// TODO
		return output;
	}
	
	/**
	 * Creates the action instance based on the action name.
	 * The action can be either an inline action or an object.
	 * The latter is created by looking up the action map specified in {@link #actions()}.
	 * @param actionID ID of the action. If empty, the {@link #getDefaultAction() default action} will be used.
	 * @return the action instance, null if the action does not exist.
	 * @see #actions()
	 */
	public Action createAction(String actionID) throws Exception
	{
		if (actionID.equals(""))
			actionID = _defaultAction;
		
		String actionMethodName = "action"+StringHelper.upperCaseFirst(actionID);
		try
		{
			getClass().getMethod(actionMethodName, new Class[] {});
			
			return new InlineAction(this, actionID);
		} catch (SecurityException e)
		{
		} catch (NoSuchMethodException e)
		{
		}
		// TODO
		throw new Exception("Action class {class} must implement the 'run' method.");
	}

	/**
	 * Handles the request whose action is not recognized.
	 * This method is invoked when the controller cannot find the requested action.
	 * The default implementation simply throws an exception.
	 * @param actionID the missing action name
	 * @throws HttpException whenever this method is invoked
	 */
	public void missingAction(String actionID) throws HttpException
	{
		throw new HttpException(404, "The system is unable to find the requested action '{action}'");
	}	
	
	/**
	 * @return the action currently being executed, null if no active action.
	 */
	public Action getAction()
	{
		return _action;
	}
	
	/**
	 * @param value the action currently being executed.
	 */
	public void setAction(Action value)
	{
		_action = value;
	}
	
	
	/**
	 * @return ID of the controller
	 */
	public String getId()
	{
		return _id;
	}

	/**
	 * @return the controller ID that is prefixed with the module ID (if any).
	 */
	public String getUniqueId()
	{
		return (_module != null) ?_module.getId()+"/"+_id : _id;
	}
	
	/**
	 * @return the route (module ID, controller ID and action ID) of the current request.
	 * @since 1.1.0
	 */
	public String getRoute()
	{
		Action action;
		if((action = getAction())!=null)
			return getUniqueId()+"/"+action.getId();
		else
			return getUniqueId();
	}
	
	/**
	 * @return the module that this controller belongs to. It returns null
	 * if the controller does not belong to any module
	 */
	public IWebModule getModule()
	{
		return _module;
	}

	public String getViewPackageName()
	{
		IWebModule module = getModule();
		if (module == null)
			module = webApp();
		return module.getViewPackageName()+"."+getId();
	}
	
	/**
	 * Returns the directory containing view files for this controller.
	 * The default implementation returns 'protected/views/ControllerID'.
	 * Child classes may override this method to use customized view path.
	 * If the controller belongs to a module, the default view path
	 * is the {@link WebModule#getViewPath() module view path} appended with the controller ID.
	 * @return the directory containing the view files for this controller. Defaults to 'protected/views/ControllerID'.
	 */
	public String getViewPath()
	{
		IWebModule module;
		if((module = (IWebModule)getModule())==null)
			module = webApp();
		return module.getViewPath()+"/"+getId();
	}
	
	/**
	 * Looks for the view file according to the given view name.
	 *
	 * When a theme is currently active, this method will call {@link Theme#getViewFile()} to determine
	 * which view file should be returned.
	 *
	 * Otherwise, this method will return the corresponding view file based on the following criteria:
	 * <ul>
	 * <li>absolute view within a module: the view name starts with a single slash '/'.
	 * In this case, the view will be searched for under the currently active module's view path.
	 * If there is no active module, the view will be searched for under the application's view path.</li>
	 * <li>absolute view within the application: the view name starts with double slashes '//'.
	 * In this case, the view will be searched for under the application's view path.
	 * This syntax has been available since version 1.1.3.</li>
	 * <li>aliased view: the view name contains dots and refers to a path alias.
	 * The view file is determined by calling {@link Root#getPathOfAlias()}. Note that aliased views
	 * cannot be themed because they can refer to a view file located at arbitrary places.</li>
	 * <li>relative view: otherwise. Relative views will be searched for under the currently active
	 * controller's view path.</li>
	 * </ul>
	 *
	 * After the view file is identified, this method may further call {@link Application#findLocalizedFile()}
	 * to find its localized version if internationalization is needed.
	 *
	 * @param viewName view name
	 * @return the view file path, false if the view file does not exist
	 * @see #resolveViewFile()
	 * @see Application#findLocalizedFile()
	 */
	public String getViewFile(String viewName)
	{
		/*
		if((($theme=Yii::app()->getTheme())!==null || ($theme=Yii::app()->themeManager->getTheme($this->getModule()!==null?$this->getModule()->theme:null))!==null) && ($viewFile=$theme->getViewFile($this,$viewName))!==false)
			return $viewFile;
		*/
		String moduleViewPath = webApp().getViewPath();
		String basePath = moduleViewPath;
		IWebModule module;
		if ((module = getModule()) != null)
			moduleViewPath = module.getViewPath();
		return resolveViewFile(viewName,getViewPath(),basePath,moduleViewPath);
	}

	/**
	 * Finds a view file based on its name.
	 * The view name can be in one of the following formats:
	 * <ul>
	 * <li>absolute view within a module: the view name starts with a single slash '/'.
	 * In this case, the view will be searched for under the currently active module's view path.
	 * If there is no active module, the view will be searched for under the application's view path.</li>
	 * <li>absolute view within the application: the view name starts with double slashes '//'.
	 * In this case, the view will be searched for under the application's view path.
	 * This syntax has been available since version 1.1.3.</li>
	 * <li>aliased view: the view name contains dots and refers to a path alias.
	 * The view file is determined by calling {@link YiiBase::getPathOfAlias()}. Note that aliased views
	 * cannot be themed because they can refer to a view file located at arbitrary places.</li>
	 * <li>relative view: otherwise. Relative views will be searched for under the currently active
	 * controller's view path.</li>
	 * </ul>
	 * For absolute view and relative view, the corresponding view file is a PHP file
	 * whose name is the same as the view name. The file is located under a specified directory.
	 * This method will call {@link Application#findLocalizedFile()} to search for a localized file, if any.
	 * @param viewName the view name
	 * @param viewPath the directory that is used to search for a relative view name
	 * @param basePath the directory that is used to search for an absolute view name under the application
	 * @param moduleViewPath the directory that is used to search for an absolute view name under the current module.
	 * If this is not set, the application base view path will be used.
	 * @return the view file path. null if the view file does not exist. blank ("") if not file based.
	 */
	public String resolveViewFile(String viewName, String viewPath, String basePath, String moduleViewPath)
	{
		if (viewName == null || viewName.equals(""))
			return null;

		if(moduleViewPath == null)
			moduleViewPath = basePath;

		IViewRenderer renderer = webApp().getViewRenderer(this, viewName);
		if (renderer.getFileExtension() == null)
			return "";
		String extension = renderer.getFileExtension();
		
		String viewFile;
		if(viewName.startsWith("/"))
		{
			if (viewName.startsWith("//"))
				viewFile=basePath+viewName;
			else
				viewFile=moduleViewPath+viewName;
		}
		else if(viewName.indexOf(".")!=-1)
			//$viewFile=Yii::getPathOfAlias($viewName);
			viewFile = viewName;
		else
			viewFile=viewPath+"/"+viewName;

		if (Object.class.getResource(viewFile+extension)!=null)
			return viewFile+extension; //Yii::app()->findLocalizedFile($viewFile.$extension);
		//else if($extension!=='.php' && is_file($viewFile.'.php'))
			//return Yii::app()->findLocalizedFile($viewFile.'.php');
		else
			return null;
	}
	
	/**
	 * @see #renderText(String, boolean)
	 */
	public void renderText(String text) throws IOException
	{
		renderText(text, false);
	}
	
	/**
	 * Renders a static text string.
	 * The string will be inserted in the current controller layout and returned back.
	 * @param text the static text string
	 * @param doReturn whether the rendering result should be returned instead of being displayed to end users.
	 * @return the rendering result. Null if the rendering result is not required.
	 * @throws IOException 
	 * @see #getLayoutFile()
	 */
	public String renderText(String text, boolean doReturn) throws IOException
	{
		//if(($layoutFile=$this->getLayoutFile($this->layout))!==false)
			//$text=$this->renderFile($layoutFile,array('content'=>$text),true);

		text = processOutput(text);

		if(doReturn)
			return text;
		else
			webApp().getResponse().getWriter().print(text);
		return null;
	}	

	/**
	 * @see #renderPartial(String, Object, boolean, boolean) 
	 */
	public String renderPartial(String view, Object data) throws IOException
	{
		return renderPartial(view, data, false, false);
	}
	
	/**
	 * @see #renderPartial(String, Object, boolean, boolean) 
	 */
	public String renderPartial(String view, Object data, boolean doReturn) throws IOException
	{
		return renderPartial(view, data, doReturn, false);
	}
	
	/**
	 * Renders a view.
	 *
	 * The named view refers to a PHP script (resolved via {@link getViewFile})
	 * that is included by this method. If $data is an associative array,
	 * it will be extracted as PHP variables and made available to the script.
	 *
	 * This method differs from {@link render()} in that it does not
	 * apply a layout to the rendered result. It is thus mostly used
	 * in rendering a partial view, or an AJAX response.
	 *
	 * @param string $view name of the view to be rendered. See {@link getViewFile} for details
	 * about how the view script is resolved.
	 * @param array $data data to be extracted into PHP variables and made available to the view script
	 * @param boolean $return whether the rendering result should be returned instead of being displayed to end users
	 * @param boolean $processOutput whether the rendering result should be postprocessed using {@link processOutput}.
	 * @return string the rendering result. Null if the rendering result is not required.
	 * @throws IOException 
	 * @throws CException if the view does not exist
	 * @see getViewFile
	 * @see processOutput
	 * @see render
	 */
	public String renderPartial(String view, Object data, boolean doReturn, boolean processOutput) throws IOException
	{
		String viewFile;
		if((viewFile=getViewFile(view))!=null)
		{
			String output = webApp().getViewRenderer(this, view).renderFile(this, viewFile, data, doReturn);
			if(processOutput)
				output = processOutput(output);
			if(doReturn)
				return output;
			else
				webApp().getResponse().getWriter().print(output);
			return null;
		}
		else
			throw new com.yiij.base.Exception("{controller} cannot find the requested view '"+view+"'.");
	}
	
}
